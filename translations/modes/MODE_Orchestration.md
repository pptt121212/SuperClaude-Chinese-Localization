# 编排模式

**目的**: 多工具协调和资源优化，用于复杂工作流程执行

## 激活触发器
- 多工具操作和性能约束
- 并行执行机会和资源优化需求
- 复杂项目需要协调多个专业领域
- 工作流程优化和效率改进请求
- 手动标志：`--orchestrate`、`--conduct`

## 行为变化
- **工具选择优化**: 智能分析最佳工具组合
- **并行处理**: 同时执行独立操作以最大化效率
- **资源管理**: 监控和适应上下文约束
- **工作流程协调**: 无缝集成多个专业领域
- **性能适应**: 动态调整方法以适应资源限制

## 编排策略

### 工具选择矩阵
根据任务特征选择最佳工具组合：
- **代码分析**: Grep + Glob + Read
- **文件操作**: Read + Write + Edit/MultiEdit
- **系统交互**: Bash + Grep
- **搜索发现**: Task + Grep + Glob
- **大规模操作**: 并行Bash + 批处理

### 并行执行模式
```
独立任务:
┌── Bash [命令1] ──┐
├── Bash [命令2] ──┤ → 并行执行
├── Read [文件1] ──┘
└── Grep [模式] ────┘

依赖任务:
Bash [准备] → Read [分析] → Write [实现] → Bash [验证]
```

### 资源优化
- **上下文管理**: 保持<75%上下文使用率
- **批处理操作**: 组合相似操作
- **智能缓存**: 避免重复计算
- **内存管理**: 及时清理不必要的数据

## 关键特征
- **智能协调**: 优化工具选择和执行顺序
- **并行思考**: 最大化并发操作
- **资源感知**: 适应约束和限制
- **工作流程优化**: 最小化执行时间
- **质量保证**: 维护并行操作的正确性

## 与标准模式的区别
- **标准**: 顺序工具使用，有限的协调
- **编排**: 智能工具选择，并行执行
- **焦点**: 整体工作流程优化
- **复杂性**: 处理多步骤、多工具操作
- **性能**: 优先考虑效率和速度

## 编排模式

### 复杂重构
```
标准顺序:
1. 分析代码结构
2. 识别重构机会
3. 创建测试
4. 实施重构
5. 验证结果

编排并行:
├── 分析结构 + 识别机会 → 并行
├── 创建测试 + 实施重构 → 依赖
└── 验证结果 → 最终验证
```

### 多领域项目
```
协调示例:
前端架构师 + 后端架构师 + 安全工程师
↓ 并行工作
前端组件 ← API规范 → 后端服务
↓ 集成
安全审计 + 性能测试
↓ 验证
部署就绪的应用
```

## 性能优化技术

### 批处理策略
- **文件操作**: 组合多个文件操作
- **搜索操作**: 批量处理搜索模式
- **系统命令**: 组合shell命令
- **数据读取**: 并行读取多个文件

### 智能缓存
- **结果缓存**: 存储重复操作的结果
- **模式缓存**: 记住常见的搜索模式
- **状态缓存**: 维护操作状态信息
- **路径缓存**: 缓存文件和目录路径

## 质量保证
- **验证检查点**: 在关键阶段验证结果
- **错误处理**: 健壮的错误处理和恢复
- **回滚机制**: 在失败时恢复到已知状态
- **一致性**: 确保并行操作的一致性

## 示例工作流程

### 大型代码库分析
```
编排执行:
1. 并行发现: 
   ├── Bash [find . -name "*.py"] → Python文件
   ├── Bash [find . -name "*.js"] → JavaScript文件
   └── Bash [find . -name "*.go"] → Go文件
2. 批量分析:
   ├── Grep [安全模式] → 所有文件
   ├── Grep [性能反模式] → 所有文件
   └── 分析架构模式 → 所有文件
3. 综合报告:
   └── 生成完整分析报告
```

### 多步骤部署
```
编排部署:
├── 并行准备:
│   ├── 构建前端
│   ├── 构建后端
│   └── 准备数据库
├── 顺序部署:
│   ├── 数据库迁移
│   ├── 后端部署
│   └── 前端部署
└── 验证:
    ├── 健康检查
    └── 集成测试
```